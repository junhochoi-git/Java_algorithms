package category.search.binary;

import java.util.Arrays;

/**
 * --------------------------------------------------------------<br/>
 * <b>프로그래머스 입국 심사</b><br/>
 * --------------------------------------------------------------<br/>
 * <b> 주요 키포인트 </b><br/>
 * 1. 왜 이분 탐색을 해야하는가?<br/>
 * 2. 어떻게 이분 탐색을 해야하는가?<br/>
 * --------------------------------------------------------------<br/>
 * <b> 나의 풀이 </b><br/>
 * 1. 입국 대기자 n은 최대 10억으로 일반적인 선형 풀이로는 어렵다.<br/>
 * - 따라서 심사관 수 m [1, 100,000] 만큼의 큐를 만들고 반복마다 t를 증가시키며 풀 순 없다.<br/>
 *
 * 2. 어떻게 풀 것인가?<br/>
 * 모든 심사관의 처리할 수 있는 최저 시간부터 최악의 경우를 start, end라 하자<br/>
 * 중간값 mid 시간에 모든 심사관이 처리 가능한 최대 인원 >= 입국 대기 인원인 경우를 결정 조건이라 하고<br/>
 * - 결정 조건에 참이라면 결정 조건이 참인 최소 결정 조건의 위치(시간)을 구하기 위해 범위를 조절한다.<br/>
 * - 결정 조건에 거짓이라면 start의 범위를 1만큼 높여서 다음 반복을 진행해 준다. <br/>
 *
 * 3. 어떻게 답을 결정할 것인가?<br/>
 * 시간에 대해 오름차순으로 연속적이므로, 이와 관련한 결정 조건 역시 [F, F, F, ... , T, T, .. T]와 같이 이루어진다.<br/>
 * 해당 문제에서 마지막 탐색에 가능한 결정 조건의 집합은 [F, T] 또는 [T, T]이다<br/>
 * 구현된 알고리즘에 따라 start = end 가 되면 주어진 문제를 해결하는 T를 결정하게 된다.<br/>
 * 모든 시간의 경우에 대해 조사하므로 [F, F]가 될 일은 해당 문제에선 없다.<br/>
 * --------------------------------------------------------------<br/>
 * <b> 채점 </b><br/>
 * <p> 메모리 100MB, 실행시간 106ms<br/>
 * --------------------------------------------------------------
 */
public class P_ArrivalCheck {
    // 최저 처리 시간 ~ 최악의 처리 시간에 대해
    // 이분 탐색으로 모든 심사관이 처리 가능한 시간 중 최소 시간을 구한다.
    // 파라메트릭 서치
    public long solution(int n, int[] times) {
        Arrays.sort(times); // times를 오름차순 정렬

        long start = 0L; // inclusive
        long end = (long)Math.pow(10, 9) * (long)Math.pow(10, 9); // inclusive

        while(start < end) {
            long mid = (start + end) / 2;
            boolean cond = isPossible(mid, times, n);

            if(cond) { // 결정 조건 만족할 때 // 최소 결정 조건의 위치를 찾아야 한다.
                // System.out.println("무야호");
                end = mid;
            } else { // 만족하지 않을 때
                start = mid + 1;
            }
        }

        return start;
    }

    // 결정 조건의 참/불 여부를 확인
    boolean isPossible(long t, int[] times, int n) {
        long count = 0;

        // 각 심사관이 자신의 처리 속도로
        // 최대 얼마나 처리 가능한지 계산하고
        // 모든 심사관의 처리 가능량을 계산
        for(int time : times) {
            count += t / time;
        }
        return n <= count; // 모든 심사관이 처리 가능한 인원 수가 n 명 이상 이상일때 결정 조건이 참
    }
}
